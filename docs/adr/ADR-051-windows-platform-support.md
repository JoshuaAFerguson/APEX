# ADR-051: Windows Platform Support for ServiceManager

## Status
Proposed

## Date
2024-12-28

## Context

The APEX ServiceManager currently supports Linux (systemd) and macOS (launchd) for daemon service management. Windows users cannot use APEX's service management capabilities, limiting cross-platform adoption.

### Current Architecture

The existing implementation follows a clean generator pattern:

```
ServiceManager
├── Platform Detection: detectPlatform() → 'linux' | 'darwin' | 'unsupported'
├── SystemdGenerator (Linux)
│   ├── generate(): string - Creates systemd unit file
│   └── getInstallPath(): string - Returns service file path
├── LaunchdGenerator (macOS)
│   ├── generate(): string - Creates launchd plist
│   └── getInstallPath(): string - Returns plist path
└── Platform-specific operations: start/stop/enable/disable/status
```

### Windows Service Management Options

1. **NSSM (Non-Sucking Service Manager)**: External wrapper that runs Node.js as a Windows Service
2. **node-windows**: NPM package for Windows Service integration
3. **WinSW**: Windows Service Wrapper (XML-based configuration)
4. **SC.exe (Service Control)**: Built-in Windows command-line tool

## Decision

We will implement Windows platform support using a **configuration-based approach** that generates files compatible with **NSSM** as the primary method, with **SC.exe** as a fallback for service control operations.

### Rationale

1. **NSSM** is widely adopted, well-documented, and handles Node.js services gracefully
2. **NSSM** supports restart policies, environment variables, and logging natively
3. **SC.exe** is available on all Windows installations for service control
4. No additional NPM dependencies required for basic functionality
5. Configuration file approach is consistent with systemd/launchd patterns

## Technical Design

### 1. Platform Type Extension

```typescript
// Current
export type Platform = 'linux' | 'darwin' | 'unsupported';

// Proposed
export type Platform = 'linux' | 'darwin' | 'win32' | 'unsupported';
```

### 2. Platform Detection Update

```typescript
export function detectPlatform(): Platform {
  const platform = process.platform;
  if (platform === 'linux') return 'linux';
  if (platform === 'darwin') return 'darwin';
  if (platform === 'win32') return 'win32';
  return 'unsupported';
}
```

### 3. WindowsServiceGenerator Class

```typescript
export class WindowsServiceGenerator {
  constructor(
    private readonly options: Required<ServiceManagerOptions>,
    private readonly enableOnBoot: boolean = false
  ) {}

  /**
   * Generate NSSM-compatible batch script for service installation
   * This creates a .bat file that can be run to register the service
   */
  generate(): string {
    const nodePath = this.getNodePath();
    const apexCliPath = this.findApexCliPath();
    const serviceName = this.options.serviceName;

    // Generate NSSM installation script
    return `@echo off
REM APEX Service Installation Script for Windows
REM Service: ${serviceName}
REM Generated by APEX ServiceManager

REM Check for administrator privileges
net session >nul 2>&1
if %errorLevel% neq 0 (
    echo This script requires administrator privileges.
    echo Please right-click and select "Run as administrator"
    pause
    exit /b 1
)

REM Install service using NSSM
nssm install ${serviceName} "${nodePath}" "${apexCliPath}" daemon start --foreground

REM Configure service parameters
nssm set ${serviceName} AppDirectory "${this.options.workingDirectory}"
nssm set ${serviceName} Description "${this.options.serviceDescription}"
nssm set ${serviceName} DisplayName "APEX Daemon - ${serviceName}"

REM Configure restart policy
${this.getRestartPolicyConfig(serviceName)}

REM Configure environment variables
nssm set ${serviceName} AppEnvironmentExtra NODE_ENV=production
nssm set ${serviceName} AppEnvironmentExtra APEX_PROJECT_PATH=${this.options.projectPath}
${this.formatEnvironment(serviceName)}

REM Configure logging
nssm set ${serviceName} AppStdout "${this.options.projectPath}\\.apex\\daemon.out.log"
nssm set ${serviceName} AppStderr "${this.options.projectPath}\\.apex\\daemon.err.log"
nssm set ${serviceName} AppStdoutCreationDisposition 4
nssm set ${serviceName} AppStderrCreationDisposition 4
nssm set ${serviceName} AppRotateFiles 1
nssm set ${serviceName} AppRotateBytes 1048576

${this.enableOnBoot ? `REM Enable service to start on boot\nnssm set ${serviceName} Start SERVICE_AUTO_START` : `REM Service will not start automatically on boot\nnssm set ${serviceName} Start SERVICE_DEMAND_START`}

echo Service ${serviceName} installed successfully.
echo To start the service: nssm start ${serviceName}
echo To check status: nssm status ${serviceName}
`;
  }

  /**
   * Generate SC.exe-compatible XML for native Windows Service (alternative)
   * This is a fallback configuration for environments without NSSM
   */
  generateAlternative(): string {
    const nodePath = this.getNodePath();
    const apexCliPath = this.findApexCliPath();

    return `<?xml version="1.0" encoding="UTF-8"?>
<!--
  APEX Windows Service Configuration
  Service: ${this.options.serviceName}

  This file is for use with WinSW or manual SC.exe configuration.
  For NSSM installation, use the generated .bat script.
-->
<service>
  <id>${this.options.serviceName}</id>
  <name>APEX Daemon - ${this.options.serviceName}</name>
  <description>${this.options.serviceDescription}</description>
  <executable>${nodePath}</executable>
  <arguments>"${apexCliPath}" daemon start --foreground</arguments>
  <workingdirectory>${this.options.workingDirectory}</workingdirectory>
  <env name="NODE_ENV" value="production"/>
  <env name="APEX_PROJECT_PATH" value="${this.options.projectPath}"/>
${Object.entries(this.options.environment).map(([key, value]) => `  <env name="${key}" value="${value}"/>`).join('\n')}
  <log mode="roll-by-size">
    <sizeThreshold>10240</sizeThreshold>
    <keepFiles>8</keepFiles>
  </log>
  <onfailure action="restart" delay="5 sec"/>
  <resetfailure>1 hour</resetfailure>
  ${this.enableOnBoot ? '<startmode>Automatic</startmode>' : '<startmode>Manual</startmode>'}
</service>
`;
  }

  getInstallPath(): string {
    // Windows services typically use Program Data or the app directory
    const apexDir = path.join(this.options.projectPath, '.apex');
    return path.join(apexDir, `${this.options.serviceName}-install.bat`);
  }

  getAlternativeInstallPath(): string {
    const apexDir = path.join(this.options.projectPath, '.apex');
    return path.join(apexDir, `${this.options.serviceName}-service.xml`);
  }

  private getNodePath(): string {
    // On Windows, use forward slashes in paths for NSSM
    return process.execPath.replace(/\\/g, '\\\\');
  }

  private getRestartPolicyConfig(serviceName: string): string {
    switch (this.options.restartPolicy) {
      case 'always':
        return `nssm set ${serviceName} AppExit Default Restart
nssm set ${serviceName} AppRestartDelay ${this.options.restartDelaySeconds * 1000}`;
      case 'on-failure':
        return `nssm set ${serviceName} AppExit Default Exit
nssm set ${serviceName} AppExit 0 Exit
nssm set ${serviceName} AppExit 1 Restart
nssm set ${serviceName} AppRestartDelay ${this.options.restartDelaySeconds * 1000}`;
      case 'never':
        return `nssm set ${serviceName} AppExit Default Exit`;
      default:
        return `nssm set ${serviceName} AppExit Default Restart
nssm set ${serviceName} AppRestartDelay ${this.options.restartDelaySeconds * 1000}`;
    }
  }

  private formatEnvironment(serviceName: string): string {
    return Object.entries(this.options.environment)
      .map(([key, value]) => `nssm set ${serviceName} AppEnvironmentExtra ${key}=${value}`)
      .join('\n');
  }

  private findApexCliPath(): string {
    // Windows-specific path resolution
    try {
      const resolved = require.resolve('@apex/cli/dist/index.js');
      return resolved.replace(/\\/g, '\\\\');
    } catch {
      const possiblePaths = [
        path.join(process.cwd(), 'node_modules', '@apex', 'cli', 'dist', 'index.js'),
        path.join(process.cwd(), 'packages', 'cli', 'dist', 'index.js'),
      ];

      for (const possiblePath of possiblePaths) {
        try {
          require('fs').accessSync(possiblePath);
          return possiblePath.replace(/\\/g, '\\\\');
        } catch {
          continue;
        }
      }

      return path.join(process.cwd(), 'node_modules', '@apex', 'cli', 'dist', 'index.js').replace(/\\/g, '\\\\');
    }
  }
}
```

### 4. Windows Availability Check

```typescript
export function isNssmAvailable(): boolean {
  // Check if NSSM is installed and accessible
  try {
    require('child_process').execSync('nssm version', { stdio: 'ignore' });
    return true;
  } catch {
    return false;
  }
}

export function isWindowsServiceAvailable(): boolean {
  // SC.exe is always available on Windows
  return process.platform === 'win32';
}
```

### 5. ServiceManager Updates

The `ServiceManager` class needs updates to:

1. **Initialize WindowsServiceGenerator** in `updateGenerator()`:
```typescript
private updateGenerator(): void {
  if (this.platform === 'linux') {
    this.generator = new SystemdGenerator(this.options, this.enableOnBoot);
  } else if (this.platform === 'darwin') {
    this.generator = new LaunchdGenerator(this.options, this.enableOnBoot);
  } else if (this.platform === 'win32') {
    this.generator = new WindowsServiceGenerator(this.options, this.enableOnBoot);
  } else {
    this.generator = null;
  }
}
```

2. **Add Windows service control methods**:
```typescript
// In enable()
} else if (this.platform === 'win32') {
  await this.execCommand(`nssm set ${this.options.serviceName} Start SERVICE_AUTO_START`);
}

// In disable()
} else if (this.platform === 'win32') {
  await this.execCommand(`nssm set ${this.options.serviceName} Start SERVICE_DEMAND_START`);
}

// In start()
} else if (this.platform === 'win32') {
  await this.execCommand(`nssm start ${this.options.serviceName}`);
}

// In stop()
} else if (this.platform === 'win32') {
  await this.execCommand(`nssm stop ${this.options.serviceName}`);
}

// In restart()
} else if (this.platform === 'win32') {
  await this.execCommand(`nssm restart ${this.options.serviceName}`);
}
```

3. **Add Windows status checking**:
```typescript
private async getWindowsStatus(servicePath: string): Promise<ServiceStatus> {
  try {
    const { stdout } = await execPromise(`nssm status ${this.options.serviceName}`);
    const running = stdout.includes('SERVICE_RUNNING');
    const installed = !stdout.includes('SERVICE_NOT_FOUND');

    // Get PID if running
    let pid: number | undefined;
    if (running) {
      try {
        const { stdout: pidOutput } = await execPromise(
          `wmic process where "name='node.exe' and commandline like '%${this.options.serviceName}%'" get processid`
        );
        const matches = pidOutput.match(/\d+/);
        if (matches) {
          pid = parseInt(matches[0], 10);
        }
      } catch {
        // PID lookup failed, continue without it
      }
    }

    return {
      installed,
      enabled: installed, // NSSM doesn't distinguish enabled/installed
      running,
      pid,
      platform: this.platform,
      servicePath,
    };
  } catch {
    return {
      installed: false,
      enabled: false,
      running: false,
      platform: this.platform,
      servicePath,
    };
  }
}
```

### 6. Generator Interface Type

For improved type safety, introduce a common interface:

```typescript
export interface ServiceGenerator {
  generate(): string;
  getInstallPath(): string;
}

// Make all generators implement this interface
export class SystemdGenerator implements ServiceGenerator { ... }
export class LaunchdGenerator implements ServiceGenerator { ... }
export class WindowsServiceGenerator implements ServiceGenerator { ... }
```

## File Structure

```
packages/orchestrator/src/
├── service-manager.ts              # Updated with Windows support
└── service-manager.test.ts         # Extended with Windows tests
```

## Test Cases Required

1. **Platform Detection Tests**:
   - `detectPlatform()` returns `'win32'` when `process.platform === 'win32'`
   - `isNssmAvailable()` returns true when NSSM is installed
   - `isWindowsServiceAvailable()` returns true on Windows

2. **WindowsServiceGenerator Tests**:
   - `generate()` produces valid NSSM installation script
   - `generateAlternative()` produces valid XML configuration
   - `getInstallPath()` returns correct Windows path
   - Environment variables are correctly formatted
   - Restart policies are correctly mapped
   - `enableOnBoot` setting affects Start mode

3. **ServiceManager Windows Integration Tests**:
   - Constructor initializes WindowsServiceGenerator on Windows
   - `install()` creates batch script
   - `start()`, `stop()`, `restart()` execute correct NSSM commands
   - `enable()`, `disable()` modify start type
   - `getStatus()` correctly parses NSSM status

4. **Edge Cases**:
   - Paths with spaces are properly quoted
   - Special characters in environment variables are escaped
   - Service names follow Windows naming conventions

## Security Considerations

1. **Administrator Privileges**: Windows service installation requires elevated permissions
2. **Path Injection**: All paths must be properly escaped to prevent command injection
3. **Service Account**: Consider adding support for running as a specific user account

## Dependencies

**Required**:
- NSSM (Non-Sucking Service Manager) must be installed and in PATH

**Optional**:
- WinSW for alternative installation method

## Migration Path

1. Update `Platform` type (non-breaking)
2. Add `WindowsServiceGenerator` class (non-breaking)
3. Update `detectPlatform()` (non-breaking - previously returned 'unsupported')
4. Update `ServiceManager` to use Windows generator (non-breaking)
5. Add Windows-specific service control methods (non-breaking)
6. Add Windows status checking (non-breaking)

## Alternatives Considered

1. **node-windows NPM package**: Would add dependency, more opinionated
2. **Pure SC.exe approach**: Limited functionality, no restart handling
3. **WinSW-only**: Requires additional binary distribution
4. **PowerShell-based**: More complex, less portable

## Consequences

### Positive
- Full Windows platform support
- Consistent API across all platforms
- No new NPM dependencies
- NSSM is well-documented and widely used

### Negative
- Requires NSSM installation on Windows
- Administrator privileges required for service management
- Windows paths are more complex to handle

### Neutral
- Different configuration format than Unix-based systems (batch vs unit files)
- Additional code path to maintain

## References

- [NSSM Documentation](https://nssm.cc/)
- [Windows Service Control (SC.exe)](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/sc-config)
- [WinSW Documentation](https://github.com/winsw/winsw)
