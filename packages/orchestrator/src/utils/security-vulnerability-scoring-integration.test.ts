/**
 * Security Vulnerability Scoring Integration Tests
 *
 * Tests the integration between SecurityVulnerabilityParser and MaintenanceAnalyzer
 * to ensure consistent scoring throughout the vulnerability processing pipeline.
 */

import { SecurityVulnerabilityParser, type NpmAuditResult } from './security-vulnerability-parser';
import { MaintenanceAnalyzer } from '../analyzers/maintenance-analyzer';
import type { ProjectAnalysis, SecurityVulnerability } from '../idle-processor';

describe('Security Vulnerability Scoring Integration', () => {
  let analyzer: MaintenanceAnalyzer;

  beforeEach(() => {
    analyzer = new MaintenanceAnalyzer();
  });

  // Helper to create ProjectAnalysis
  function createAnalysisWithVulnerabilities(securityIssues: SecurityVulnerability[]): ProjectAnalysis {
    return {
      codebaseSize: {
        files: 100,
        lines: 10000,
        languages: { typescript: 8000, javascript: 2000 }
      },
      testCoverage: undefined,
      dependencies: {
        outdated: [],
        security: [],
        securityIssues
      },
      codeQuality: {
        lintIssues: 0,
        duplicatedCode: [],
        complexityHotspots: [],
        codeSmells: []
      },
      documentation: {
        coverage: 50,
        missingDocs: [],
        outdatedSections: [],
        apiCompleteness: {
          percentage: 75,
          details: {
            totalEndpoints: 20,
            documentedEndpoints: 15,
            undocumentedItems: [],
            wellDocumentedExamples: [],
            commonIssues: []
          }
        }
      },
      performance: {
        bundleSize: undefined,
        slowTests: [],
        bottlenecks: []
      }
    };
  }

  describe('CVSS-based Severity Scoring Integration', () => {
    it('should correctly map CVSS scores to severity levels and task scores', () => {
      const testCases = [
        { cvssScore: 10.0, expectedSeverity: 'critical', expectedTaskScore: 1.0 },
        { cvssScore: 9.5, expectedSeverity: 'critical', expectedTaskScore: 1.0 },
        { cvssScore: 9.0, expectedSeverity: 'critical', expectedTaskScore: 1.0 },
        { cvssScore: 8.9, expectedSeverity: 'high', expectedTaskScore: 0.9 },
        { cvssScore: 8.0, expectedSeverity: 'high', expectedTaskScore: 0.9 },
        { cvssScore: 7.0, expectedSeverity: 'high', expectedTaskScore: 0.9 },
        { cvssScore: 6.9, expectedSeverity: 'medium', expectedTaskScore: 0.7 },
        { cvssScore: 5.0, expectedSeverity: 'medium', expectedTaskScore: 0.7 },
        { cvssScore: 4.0, expectedSeverity: 'medium', expectedTaskScore: 0.7 },
        { cvssScore: 3.9, expectedSeverity: 'low', expectedTaskScore: 0.5 },
        { cvssScore: 2.0, expectedSeverity: 'low', expectedTaskScore: 0.5 },
        { cvssScore: 0.1, expectedSeverity: 'low', expectedTaskScore: 0.5 },
        { cvssScore: 0.0, expectedSeverity: 'low', expectedTaskScore: 0.5 }
      ];

      testCases.forEach(({ cvssScore, expectedSeverity, expectedTaskScore }) => {
        // Test parser mapping
        const mappedSeverity = SecurityVulnerabilityParser.severityFromCVSS(cvssScore);
        expect(mappedSeverity).toBe(expectedSeverity);

        // Test end-to-end scoring in analyzer
        const vulnerability = SecurityVulnerabilityParser.createVulnerability({
          name: `test-pkg-${cvssScore}`,
          cveId: `CVE-2024-${String(Math.floor(cvssScore * 1000)).padStart(4, '0')}`,
          severity: mappedSeverity,
          description: `CVSS ${cvssScore} vulnerability`
        });

        const analysis = createAnalysisWithVulnerabilities([vulnerability]);
        const candidates = analyzer.analyze(analysis);

        const securityTask = candidates.find(c => c.candidateId.includes('security'));
        expect(securityTask).toBeDefined();
        expect(securityTask!.score).toBe(expectedTaskScore);
      });
    });
  });

  describe('npm audit Integration', () => {
    it('should maintain correct scoring when processing npm audit output', () => {
      const npmAuditData: NpmAuditResult = {
        auditReportVersion: 2,
        vulnerabilities: {
          'critical-package': {
            name: 'critical-package',
            severity: 'critical',
            isDirect: false,
            via: [{
              source: 1001,
              name: 'critical-package',
              title: 'Critical RCE vulnerability',
              url: 'https://nvd.nist.gov/vuln/detail/CVE-2024-0001',
              severity: 'critical',
              cwe: ['CWE-94'],
              cvss: { score: 9.8 },
              range: '<2.0.0'
            }],
            effects: [],
            range: '<2.0.0',
            nodes: ['node_modules/critical-package'],
            fixAvailable: true
          },
          'high-package': {
            name: 'high-package',
            severity: 'high',
            isDirect: false,
            via: [{
              source: 1002,
              name: 'high-package',
              title: 'High severity vulnerability',
              url: 'https://nvd.nist.gov/vuln/detail/CVE-2024-0002',
              severity: 'high',
              cwe: ['CWE-79'],
              cvss: { score: 7.5 },
              range: '<1.5.0'
            }],
            effects: [],
            range: '<1.5.0',
            nodes: ['node_modules/high-package'],
            fixAvailable: true
          },
          'medium-package': {
            name: 'medium-package',
            severity: 'moderate',
            isDirect: false,
            via: [{
              source: 1003,
              name: 'medium-package',
              title: 'Medium severity vulnerability',
              severity: 'moderate',
              cvss: { score: 5.3 },
              range: '<1.0.0'
            }],
            effects: [],
            range: '<1.0.0',
            nodes: ['node_modules/medium-package'],
            fixAvailable: true
          },
          'low-package': {
            name: 'low-package',
            severity: 'low',
            isDirect: false,
            via: [{
              source: 1004,
              name: 'low-package',
              title: 'Low severity information disclosure',
              severity: 'low',
              cvss: { score: 2.1 },
              range: '<0.5.0'
            }],
            effects: [],
            range: '<0.5.0',
            nodes: ['node_modules/low-package'],
            fixAvailable: false
          }
        }
      };

      // Parse npm audit output
      const parsedVulnerabilities = SecurityVulnerabilityParser.parseNpmAuditOutput(npmAuditData);

      // Verify parser correctly assigned severities
      const severities = parsedVulnerabilities.map(v => v.severity).sort();
      expect(severities).toEqual(['critical', 'high', 'low', 'medium']);

      // Test analyzer scoring
      const analysis = createAnalysisWithVulnerabilities(parsedVulnerabilities);
      const candidates = analyzer.analyze(analysis);

      // Find tasks by priority
      const urgentTasks = candidates.filter(c => c.priority === 'urgent');
      const highTasks = candidates.filter(c => c.priority === 'high');
      const normalTasks = candidates.filter(c => c.priority === 'normal');
      const lowTasks = candidates.filter(c => c.priority === 'low');

      // Verify correct task counts and scores
      expect(urgentTasks).toHaveLength(1);
      expect(urgentTasks[0].score).toBe(1.0);

      expect(highTasks).toHaveLength(1);
      expect(highTasks[0].score).toBe(0.9);

      expect(normalTasks).toHaveLength(1);
      expect(normalTasks[0].score).toBe(0.7);

      expect(lowTasks).toHaveLength(1);
      expect(lowTasks[0].score).toBe(0.5);
    });

    it('should handle npm audit data without CVSS scores but with severity labels', () => {
      const npmAuditData: NpmAuditResult = {
        vulnerabilities: {
          'no-cvss-high': {
            name: 'no-cvss-high',
            severity: 'high',
            isDirect: false,
            via: [{
              name: 'no-cvss-high',
              title: 'High severity without CVSS',
              severity: 'high',
              range: '<1.0.0'
            }],
            effects: [],
            range: '<1.0.0',
            nodes: ['node_modules/no-cvss-high'],
            fixAvailable: true
          },
          'no-cvss-moderate': {
            name: 'no-cvss-moderate',
            severity: 'moderate',
            isDirect: false,
            via: [{
              name: 'no-cvss-moderate',
              title: 'Moderate severity without CVSS',
              severity: 'moderate',
              range: '<2.0.0'
            }],
            effects: [],
            range: '<2.0.0',
            nodes: ['node_modules/no-cvss-moderate'],
            fixAvailable: true
          }
        }
      };

      const parsedVulnerabilities = SecurityVulnerabilityParser.parseNpmAuditOutput(npmAuditData);
      const analysis = createAnalysisWithVulnerabilities(parsedVulnerabilities);
      const candidates = analyzer.analyze(analysis);

      const highTask = candidates.find(c => c.priority === 'high');
      const mediumTask = candidates.find(c => c.priority === 'normal');

      expect(highTask).toBeDefined();
      expect(highTask!.score).toBe(0.9);

      expect(mediumTask).toBeDefined();
      expect(mediumTask!.score).toBe(0.7);
    });
  });

  describe('CVSS Score Boundary Testing', () => {
    it('should correctly handle CVSS boundary values that affect scoring', () => {
      const boundaryTests = [
        { cvss: 8.99, expectedSeverity: 'high', expectedScore: 0.9 },
        { cvss: 9.0, expectedSeverity: 'critical', expectedScore: 1.0 },
        { cvss: 6.99, expectedSeverity: 'medium', expectedScore: 0.7 },
        { cvss: 7.0, expectedSeverity: 'high', expectedScore: 0.9 },
        { cvss: 3.99, expectedSeverity: 'low', expectedScore: 0.5 },
        { cvss: 4.0, expectedSeverity: 'medium', expectedScore: 0.7 }
      ];

      boundaryTests.forEach(({ cvss, expectedSeverity, expectedScore }) => {
        const severity = SecurityVulnerabilityParser.severityFromCVSS(cvss);
        expect(severity).toBe(expectedSeverity);

        const vulnerability = SecurityVulnerabilityParser.createVulnerability({
          name: `boundary-test-${cvss}`,
          severity,
          description: `Boundary test for CVSS ${cvss}`
        });

        const analysis = createAnalysisWithVulnerabilities([vulnerability]);
        const candidates = analyzer.analyze(analysis);

        const task = candidates.find(c => c.candidateId.includes('security'));
        expect(task).toBeDefined();
        expect(task!.score).toBe(expectedScore);
      });
    });
  });

  describe('Complex Integration Scenarios', () => {
    it('should maintain score consistency across mixed vulnerability sources', () => {
      // Create vulnerabilities from different sources but same severities
      const parserCreated = SecurityVulnerabilityParser.createVulnerability({
        name: 'parser-created',
        severity: 'high',
        cveId: 'CVE-2024-1111'
      });

      const npmParsed = SecurityVulnerabilityParser.parseNpmAuditOutput({
        vulnerabilities: {
          'npm-parsed': {
            name: 'npm-parsed',
            severity: 'high',
            isDirect: false,
            via: [{
              name: 'npm-parsed',
              title: 'npm parsed vulnerability',
              severity: 'high',
              cvss: { score: 8.0 },
              range: '<1.0.0'
            }],
            effects: [],
            range: '<1.0.0',
            nodes: ['node_modules/npm-parsed'],
            fixAvailable: true
          }
        }
      });

      const allVulnerabilities = [parserCreated, ...npmParsed];
      const analysis = createAnalysisWithVulnerabilities(allVulnerabilities);
      const candidates = analyzer.analyze(analysis);

      // Both should result in high-priority tasks with 0.9 score
      const highTasks = candidates.filter(c => c.priority === 'high');
      expect(highTasks).toHaveLength(2);

      highTasks.forEach(task => {
        expect(task.score).toBe(0.9);
      });
    });

    it('should prioritize correctly when combined with non-security maintenance tasks', () => {
      const vulnerabilities = [
        SecurityVulnerabilityParser.createVulnerability({
          name: 'critical-security',
          severity: 'critical',
          cveId: 'CVE-2024-0001'
        }),
        SecurityVulnerabilityParser.createVulnerability({
          name: 'low-security1',
          severity: 'low',
          cveId: 'CVE-2024-0002'
        }),
        SecurityVulnerabilityParser.createVulnerability({
          name: 'low-security2',
          severity: 'low',
          cveId: 'CVE-2024-0003'
        })
      ];

      const analysisWithMixed: ProjectAnalysis = {
        ...createAnalysisWithVulnerabilities(vulnerabilities),
        dependencies: {
          outdated: ['old-package@0.1.0'],
          security: [],
          securityIssues: vulnerabilities
        }
      };

      const candidates = analyzer.analyze(analysisWithMixed);

      // Sort by score to verify priority order
      const sorted = [...candidates].sort((a, b) => b.score - a.score);

      // Critical security should be first (1.0)
      expect(sorted[0].score).toBe(1.0);
      expect(sorted[0].candidateId).toContain('security');

      // Then either outdated deps (0.5) or low security (0.5)
      // Both should have same score, but security should come first by type
      const lowScoreTasks = sorted.filter(c => c.score === 0.5);
      expect(lowScoreTasks.length).toBeGreaterThanOrEqual(2);
    });
  });

  describe('Validation and Error Handling', () => {
    it('should validate vulnerabilities have correct score mapping', () => {
      const testVulnerabilities = [
        { severity: 'critical' as const },
        { severity: 'high' as const },
        { severity: 'medium' as const },
        { severity: 'low' as const }
      ].map((props, i) =>
        SecurityVulnerabilityParser.createVulnerability({
          name: `test-${i}`,
          ...props
        })
      );

      // Validate each vulnerability
      testVulnerabilities.forEach(vuln => {
        expect(SecurityVulnerabilityParser.isValidVulnerability(vuln)).toBe(true);
      });

      const analysis = createAnalysisWithVulnerabilities(testVulnerabilities);
      const candidates = analyzer.analyze(analysis);

      // Verify all tasks have valid scores
      const securityTasks = candidates.filter(c => c.candidateId.includes('security'));
      const scores = securityTasks.map(t => t.score);
      const expectedScores = [1.0, 0.9, 0.7, 0.5];

      expect(scores.sort((a, b) => b - a)).toEqual(expectedScores);
    });

    it('should handle edge cases gracefully without breaking score consistency', () => {
      // Test with empty arrays, single items, etc.
      const edgeCases = [
        [], // Empty
        [SecurityVulnerabilityParser.createVulnerability({ name: 'single', severity: 'medium' })], // Single
        Array.from({ length: 100 }, (_, i) => // Many
          SecurityVulnerabilityParser.createVulnerability({
            name: `bulk-${i}`,
            severity: 'low'
          })
        )
      ];

      edgeCases.forEach((vulns, caseIndex) => {
        const analysis = createAnalysisWithVulnerabilities(vulns);
        const candidates = analyzer.analyze(analysis);

        // Verify all security tasks have valid scores
        const securityTasks = candidates.filter(c => c.candidateId.includes('security'));
        securityTasks.forEach(task => {
          expect([1.0, 0.9, 0.7, 0.5]).toContain(task.score);
        });
      });
    });
  });
});