/**
 * Security Vulnerability Parser
 *
 * Parses CVE identifiers, CVSS scores, and vulnerability data
 * from various input sources (npm audit, manual entries, etc.)
 */

import type { SecurityVulnerability, VulnerabilitySeverity } from '../idle-processor';

/**
 * CVSS Score object as returned by npm audit
 */
export interface CVSSScore {
  score: number;
  vectorString?: string;
}

/**
 * Parsed CVE information
 */
export interface ParsedCVE {
  id: string;           // Full CVE ID (e.g., "CVE-2021-44228")
  year: number;         // Year component (e.g., 2021)
  sequence: number;     // Sequence number (e.g., 44228)
}

/**
 * npm audit vulnerability structure (v2+ format)
 */
export interface NpmAuditVulnerability {
  name: string;
  severity: string;
  isDirect: boolean;
  via: NpmAuditVia[];
  effects: string[];
  range: string;
  nodes: string[];
  fixAvailable: boolean | NpmAuditFix;
}

export interface NpmAuditVia {
  source?: number;
  name?: string;
  dependency?: string;
  title?: string;
  url?: string;
  severity?: string;
  cwe?: string[];
  cvss?: CVSSScore;
  range?: string;
}

export interface NpmAuditFix {
  name: string;
  version: string;
  isSemVerMajor: boolean;
}

export interface NpmAuditResult {
  auditReportVersion?: number;
  vulnerabilities: Record<string, NpmAuditVulnerability>;
  metadata?: {
    vulnerabilities: {
      info: number;
      low: number;
      moderate: number;
      high: number;
      critical: number;
      total: number;
    };
  };
}

/**
 * CVSS Score thresholds per CVSS v3.1 specification
 * @see https://www.first.org/cvss/v3.1/specification-document
 */
const CVSS_THRESHOLDS = {
  CRITICAL: 9.0,
  HIGH: 7.0,
  MEDIUM: 4.0,
  LOW: 0.1,
} as const;

/**
 * Severity label mappings for fallback when CVSS is unavailable
 */
const SEVERITY_LABELS: Record<string, VulnerabilitySeverity> = {
  'critical': 'critical',
  'high': 'high',
  'moderate': 'medium',
  'medium': 'medium',
  'low': 'low',
  'info': 'low',
  'informational': 'low',
} as const;

/**
 * Security Vulnerability Parser
 *
 * Provides utilities for parsing and categorizing security vulnerabilities
 * with CVE pattern matching and CVSS-based severity classification.
 */
export class SecurityVulnerabilityParser {
  // CVE pattern: CVE-YYYY-NNNNN (4+ digits after year)
  private static readonly CVE_PATTERN = /CVE-(\d{4})-(\d{4,})/gi;

  // CVSS score patterns: matches various formats
  private static readonly CVSS_PATTERNS = [
    /(?:cvss[:\s]*)?(\d+(?:\.\d+)?)/i,           // "CVSS: 9.8" or "cvss": 9.8
    /"score"[:\s]*(\d+(?:\.\d+)?)/i,             // "score": 9.8
    /score[:\s]*(\d+(?:\.\d+)?)/i,               // score: 9.8
  ];

  /**
   * Extract all CVE identifiers from a string
   *
   * @param input - Text to search for CVE patterns
   * @returns Array of CVE identifiers (normalized to uppercase)
   *
   * @example
   * ```typescript
   * extractCVEs('Found CVE-2021-44228 in log4j')
   * // Returns: ['CVE-2021-44228']
   *
   * extractCVEs('CVE-2021-44228 and cve-2023-12345')
   * // Returns: ['CVE-2021-44228', 'CVE-2023-12345']
   * ```
   */
  static extractCVEs(input: string): string[] {
    if (!input || typeof input !== 'string') {
      return [];
    }

    const matches = Array.from(input.matchAll(this.CVE_PATTERN));
    return matches.map(match => `CVE-${match[1]}-${match[2]}`);
  }

  /**
   * Validate a CVE identifier format
   *
   * @param cveId - CVE identifier to validate
   * @returns True if the CVE format is valid
   *
   * @example
   * ```typescript
   * isValidCVE('CVE-2021-44228')     // true
   * isValidCVE('CVE-2024-000001')    // true (extended format)
   * isValidCVE('CVE-21-1234')        // false (invalid year)
   * isValidCVE('CVE-2021-123')       // false (sequence too short)
   * ```
   */
  static isValidCVE(cveId: string): boolean {
    if (!cveId || typeof cveId !== 'string') {
      return false;
    }

    // Reset regex global state
    this.CVE_PATTERN.lastIndex = 0;
    return this.CVE_PATTERN.test(cveId);
  }

  /**
   * Parse CVE components from identifier
   *
   * @param cveId - CVE identifier to parse
   * @returns Parsed CVE object or null if invalid
   *
   * @example
   * ```typescript
   * parseCVE('CVE-2021-44228')
   * // Returns: { id: 'CVE-2021-44228', year: 2021, sequence: 44228 }
   * ```
   */
  static parseCVE(cveId: string): ParsedCVE | null {
    if (!this.isValidCVE(cveId)) {
      return null;
    }

    // Reset regex global state and extract components
    this.CVE_PATTERN.lastIndex = 0;
    const match = this.CVE_PATTERN.exec(cveId.toUpperCase());

    if (!match) {
      return null;
    }

    return {
      id: `CVE-${match[1]}-${match[2]}`,
      year: parseInt(match[1], 10),
      sequence: parseInt(match[2], 10),
    };
  }

  /**
   * Parse CVSS score from various formats
   *
   * @param input - String, number, or object containing CVSS data
   * @returns CVSS score (0.0-10.0) or null if not found/invalid
   *
   * @example
   * ```typescript
   * parseCVSSScore('CVSS: 9.8')          // 9.8
   * parseCVSSScore(9.8)                  // 9.8
   * parseCVSSScore({ score: 9.8 })       // 9.8
   * parseCVSSScore('invalid')            // null
   * ```
   */
  static parseCVSSScore(input: string | number | object): number | null {
    if (typeof input === 'number') {
      return this.validateCVSSScore(input);
    }

    if (typeof input === 'object' && input !== null) {
      // Handle objects like { score: 9.8 } or { cvss: { score: 9.8 } }
      const obj = input as any;

      if (typeof obj.score === 'number') {
        return this.validateCVSSScore(obj.score);
      }

      if (obj.cvss && typeof obj.cvss.score === 'number') {
        return this.validateCVSSScore(obj.cvss.score);
      }

      // Convert object to string for pattern matching
      input = JSON.stringify(input);
    }

    if (typeof input !== 'string') {
      return null;
    }

    // Try each CVSS pattern
    for (const pattern of this.CVSS_PATTERNS) {
      pattern.lastIndex = 0; // Reset global state
      const match = pattern.exec(input);
      if (match) {
        const score = parseFloat(match[1]);
        return this.validateCVSSScore(score);
      }
    }

    return null;
  }

  /**
   * Validate CVSS score is within valid range (0.0-10.0)
   */
  private static validateCVSSScore(score: number): number | null {
    if (isNaN(score) || score < 0) {
      return null;
    }
    // Cap at 10.0 for defensive programming
    return Math.min(score, 10.0);
  }

  /**
   * Map CVSS score to severity level per CVSS v3.1 specification
   *
   * @param score - CVSS score (0.0-10.0)
   * @returns Severity level
   *
   * @example
   * ```typescript
   * severityFromCVSS(10.0)  // 'critical'
   * severityFromCVSS(8.5)   // 'high'
   * severityFromCVSS(5.0)   // 'medium'
   * severityFromCVSS(2.0)   // 'low'
   * ```
   */
  static severityFromCVSS(score: number): VulnerabilitySeverity {
    if (score >= CVSS_THRESHOLDS.CRITICAL) return 'critical';
    if (score >= CVSS_THRESHOLDS.HIGH) return 'high';
    if (score >= CVSS_THRESHOLDS.MEDIUM) return 'medium';
    return 'low';
  }

  /**
   * Infer severity from string labels (fallback when CVSS unavailable)
   *
   * @param label - Severity label string
   * @returns Severity level
   *
   * @example
   * ```typescript
   * parseSeverityLabel('critical')      // 'critical'
   * parseSeverityLabel('moderate')      // 'medium'
   * parseSeverityLabel('unknown')       // 'low' (default)
   * ```
   */
  static parseSeverityLabel(label: string): VulnerabilitySeverity {
    if (!label || typeof label !== 'string') {
      return 'low';
    }

    const normalized = label.toLowerCase().trim();
    return SEVERITY_LABELS[normalized] ?? 'low';
  }

  /**
   * Parse npm audit JSON output into SecurityVulnerability[]
   *
   * @param auditJson - Raw npm audit JSON output
   * @returns Array of parsed security vulnerabilities
   *
   * @example
   * ```typescript
   * const auditOutput = JSON.parse(await execAsync('npm audit --json'));
   * const vulnerabilities = parseNpmAuditOutput(auditOutput);
   * ```
   */
  static parseNpmAuditOutput(auditJson: any): SecurityVulnerability[] {
    const vulnerabilities: SecurityVulnerability[] = [];

    try {
      if (!auditJson || typeof auditJson !== 'object') {
        return vulnerabilities;
      }

      const auditData = auditJson as NpmAuditResult;

      if (!auditData.vulnerabilities || typeof auditData.vulnerabilities !== 'object') {
        return vulnerabilities;
      }

      // Process each vulnerability from npm audit
      for (const [packageName, vulnData] of Object.entries(auditData.vulnerabilities)) {
        try {
          const vulnerability = this.parseNpmVulnerability(packageName, vulnData);
          if (vulnerability) {
            vulnerabilities.push(vulnerability);
          }
        } catch (error) {
          // Skip malformed vulnerability entries but continue processing others
          console.warn(`Failed to parse vulnerability for ${packageName}:`, error);
        }
      }
    } catch (error) {
      // Return empty array on parsing errors
      console.warn('Failed to parse npm audit output:', error);
    }

    return vulnerabilities;
  }

  /**
   * Parse individual npm audit vulnerability entry
   */
  private static parseNpmVulnerability(
    packageName: string,
    vulnData: NpmAuditVulnerability
  ): SecurityVulnerability | null {
    try {
      let cveId = '';
      let description = '';
      let cvssScore: number | null = null;
      let severity: VulnerabilitySeverity = 'low';

      // Extract information from 'via' array (contains detailed vulnerability info)
      if (Array.isArray(vulnData.via)) {
        for (const via of vulnData.via) {
          // Extract CVE from URL if available
          if (via.url && !cveId) {
            const extractedCVEs = this.extractCVEs(via.url);
            if (extractedCVEs.length > 0) {
              cveId = extractedCVEs[0];
            }
          }

          // Use title as description if available
          if (via.title && !description) {
            description = via.title;
          }

          // Extract CVSS score
          if (via.cvss && !cvssScore) {
            cvssScore = this.parseCVSSScore(via.cvss);
          }

          // Use severity from via if available
          if (via.severity && cvssScore === null) {
            severity = this.parseSeverityLabel(via.severity);
          }
        }
      }

      // Fall back to top-level severity if no CVSS found
      if (cvssScore !== null) {
        severity = this.severityFromCVSS(cvssScore);
      } else if (vulnData.severity) {
        severity = this.parseSeverityLabel(vulnData.severity);
      }

      // Generate a placeholder CVE if none found
      if (!cveId) {
        // Check if package name contains CVE pattern
        const extractedFromName = this.extractCVEs(packageName);
        if (extractedFromName.length > 0) {
          cveId = extractedFromName[0];
        } else {
          // Use a descriptive placeholder that indicates no CVE available
          cveId = `NO-CVE-${packageName.toUpperCase()}-${severity.toUpperCase()}`;
        }
      }

      // Use a meaningful description if none found
      if (!description) {
        description = `Security vulnerability in ${packageName}`;
      }

      return this.createVulnerability({
        name: packageName,
        cveId,
        severity,
        affectedVersions: vulnData.range || 'unknown',
        description,
      });
    } catch (error) {
      console.warn(`Failed to parse vulnerability data for ${packageName}:`, error);
      return null;
    }
  }

  /**
   * Create a SecurityVulnerability from partial data with validation
   *
   * @param data - Partial vulnerability data (name is required)
   * @returns Complete SecurityVulnerability object
   *
   * @example
   * ```typescript
   * const vuln = createVulnerability({
   *   name: 'lodash',
   *   cveId: 'CVE-2021-44228',
   *   severity: 'critical'
   * });
   * ```
   */
  static createVulnerability(
    data: Partial<SecurityVulnerability> & { name: string }
  ): SecurityVulnerability {
    return {
      name: data.name,
      cveId: data.cveId || `NO-CVE-${data.name.toUpperCase()}`,
      severity: data.severity || 'low',
      affectedVersions: data.affectedVersions || 'unknown',
      description: data.description || `Security vulnerability in ${data.name}`,
    };
  }

  /**
   * Validate a SecurityVulnerability object
   *
   * @param vulnerability - Vulnerability object to validate
   * @returns True if valid, false otherwise
   */
  static isValidVulnerability(vulnerability: any): vulnerability is SecurityVulnerability {
    return (
      vulnerability &&
      typeof vulnerability === 'object' &&
      typeof vulnerability.name === 'string' &&
      vulnerability.name.length > 0 &&
      typeof vulnerability.cveId === 'string' &&
      typeof vulnerability.severity === 'string' &&
      ['critical', 'high', 'medium', 'low'].includes(vulnerability.severity) &&
      typeof vulnerability.affectedVersions === 'string' &&
      typeof vulnerability.description === 'string'
    );
  }
}