# Technical Design: Security Vulnerability Detection

## Overview

This document provides detailed implementation specifications for the security vulnerability detection feature with CVE pattern matching and severity categorization.

## Interface Definitions

### Core Types (Already Exist in `idle-processor.ts`)

```typescript
export type VulnerabilitySeverity = 'critical' | 'high' | 'medium' | 'low';

export interface SecurityVulnerability {
  name: string;           // Package name affected
  cveId: string;          // CVE identifier (e.g., "CVE-2021-44228")
  severity: VulnerabilitySeverity;
  affectedVersions: string;
  description: string;
}
```

### New Types for Parser

```typescript
/**
 * CVSS Score object as returned by npm audit
 */
export interface CVSSScore {
  score: number;
  vectorString?: string;
}

/**
 * Parsed CVE information
 */
export interface ParsedCVE {
  id: string;           // Full CVE ID (e.g., "CVE-2021-44228")
  year: number;         // Year component (e.g., 2021)
  sequence: number;     // Sequence number (e.g., 44228)
}

/**
 * npm audit vulnerability structure (v2+ format)
 */
export interface NpmAuditVulnerability {
  name: string;
  severity: string;
  isDirect: boolean;
  via: NpmAuditVia[];
  effects: string[];
  range: string;
  nodes: string[];
  fixAvailable: boolean | NpmAuditFix;
}

export interface NpmAuditVia {
  source?: number;
  name?: string;
  dependency?: string;
  title?: string;
  url?: string;
  severity?: string;
  cwe?: string[];
  cvss?: CVSSScore;
  range?: string;
}

export interface NpmAuditFix {
  name: string;
  version: string;
  isSemVerMajor: boolean;
}

export interface NpmAuditResult {
  auditReportVersion?: number;
  vulnerabilities: Record<string, NpmAuditVulnerability>;
  metadata?: {
    vulnerabilities: {
      info: number;
      low: number;
      moderate: number;
      high: number;
      critical: number;
      total: number;
    };
  };
}
```

## Implementation Specifications

### File: `packages/orchestrator/src/utils/security-vulnerability-parser.ts`

```typescript
import type { SecurityVulnerability, VulnerabilitySeverity } from '../idle-processor';

/**
 * CVSS Score thresholds per CVSS v3.1 specification
 * @see https://www.first.org/cvss/v3.1/specification-document
 */
const CVSS_THRESHOLDS = {
  CRITICAL: 9.0,
  HIGH: 7.0,
  MEDIUM: 4.0,
  LOW: 0.1,
} as const;

/**
 * CVE pattern regex - matches CVE-YYYY-NNNNN format
 * Year: 4 digits (1999-2099 practical range)
 * Sequence: 4+ digits (extended format allows longer sequences)
 */
const CVE_REGEX = /CVE-(\d{4})-(\d{4,})/gi;

/**
 * Severity label mappings for string-to-enum conversion
 */
const SEVERITY_LABELS: Record<string, VulnerabilitySeverity> = {
  'critical': 'critical',
  'high': 'high',
  'moderate': 'medium',  // npm uses "moderate" instead of "medium"
  'medium': 'medium',
  'low': 'low',
  'info': 'low',
  'informational': 'low',
};

export class SecurityVulnerabilityParser {
  /**
   * Extract all CVE identifiers from a string.
   * Returns normalized uppercase CVE IDs.
   *
   * @param input - String to search for CVE patterns
   * @returns Array of CVE identifiers in uppercase format
   *
   * @example
   * extractCVEs("Found CVE-2021-44228 in log4j")
   * // => ["CVE-2021-44228"]
   */
  static extractCVEs(input: string): string[] {
    const matches: string[] = [];
    let match: RegExpExecArray | null;

    // Reset regex lastIndex for fresh search
    CVE_REGEX.lastIndex = 0;

    while ((match = CVE_REGEX.exec(input)) !== null) {
      const year = match[1];
      const sequence = match[2];
      matches.push(`CVE-${year}-${sequence}`);
    }

    // Remove duplicates and return
    return [...new Set(matches)];
  }

  /**
   * Validate a CVE identifier format.
   *
   * @param cveId - String to validate
   * @returns true if valid CVE format
   *
   * @example
   * isValidCVE("CVE-2021-44228") // => true
   * isValidCVE("CVE-21-123")     // => false (year too short)
   * isValidCVE("CVE-2021-123")   // => false (sequence too short)
   */
  static isValidCVE(cveId: string): boolean {
    const pattern = /^CVE-\d{4}-\d{4,}$/i;
    return pattern.test(cveId);
  }

  /**
   * Parse a CVE identifier into its components.
   *
   * @param cveId - CVE identifier string
   * @returns Parsed CVE object or null if invalid
   */
  static parseCVE(cveId: string): ParsedCVE | null {
    const match = /^CVE-(\d{4})-(\d{4,})$/i.exec(cveId);
    if (!match) return null;

    return {
      id: `CVE-${match[1]}-${match[2]}`,
      year: parseInt(match[1], 10),
      sequence: parseInt(match[2], 10),
    };
  }

  /**
   * Parse CVSS score from various input formats.
   *
   * @param input - Number, string, or CVSS object
   * @returns CVSS score (0-10) or null if unparseable
   *
   * @example
   * parseCVSSScore(9.8)                        // => 9.8
   * parseCVSSScore("9.8")                      // => 9.8
   * parseCVSSScore({ score: 9.8 })             // => 9.8
   * parseCVSSScore("CVSS: 9.8")                // => 9.8
   */
  static parseCVSSScore(input: unknown): number | null {
    if (input === null || input === undefined) {
      return null;
    }

    // Direct number
    if (typeof input === 'number') {
      return this.clampCVSS(input);
    }

    // Object with score property
    if (typeof input === 'object' && input !== null && 'score' in input) {
      const obj = input as { score: unknown };
      if (typeof obj.score === 'number') {
        return this.clampCVSS(obj.score);
      }
    }

    // String parsing
    if (typeof input === 'string') {
      // Try direct number parse
      const direct = parseFloat(input);
      if (!isNaN(direct)) {
        return this.clampCVSS(direct);
      }

      // Try extracting from "CVSS: X.X" format
      const match = /(\d+(?:\.\d+)?)/i.exec(input);
      if (match) {
        const score = parseFloat(match[1]);
        if (!isNaN(score)) {
          return this.clampCVSS(score);
        }
      }
    }

    return null;
  }

  /**
   * Clamp CVSS score to valid range [0, 10]
   */
  private static clampCVSS(score: number): number {
    return Math.max(0, Math.min(10, score));
  }

  /**
   * Map CVSS score to severity level.
   *
   * @param score - CVSS score (0-10)
   * @returns Severity level
   *
   * Score ranges per CVSS v3.1:
   * - Critical: 9.0 - 10.0
   * - High: 7.0 - 8.9
   * - Medium: 4.0 - 6.9
   * - Low: 0.1 - 3.9
   */
  static severityFromCVSS(score: number): VulnerabilitySeverity {
    if (score >= CVSS_THRESHOLDS.CRITICAL) return 'critical';
    if (score >= CVSS_THRESHOLDS.HIGH) return 'high';
    if (score >= CVSS_THRESHOLDS.MEDIUM) return 'medium';
    return 'low';
  }

  /**
   * Parse severity from string label.
   * Handles various formats including npm's "moderate".
   *
   * @param label - Severity label string
   * @returns Normalized severity level
   */
  static parseSeverityLabel(label: string): VulnerabilitySeverity {
    const normalized = label.toLowerCase().trim();
    return SEVERITY_LABELS[normalized] ?? 'low';
  }

  /**
   * Parse npm audit JSON output into SecurityVulnerability array.
   *
   * @param auditJson - Parsed npm audit --json output
   * @returns Array of SecurityVulnerability objects
   */
  static parseNpmAuditOutput(auditJson: unknown): SecurityVulnerability[] {
    const vulnerabilities: SecurityVulnerability[] = [];

    if (!auditJson || typeof auditJson !== 'object') {
      return vulnerabilities;
    }

    const audit = auditJson as NpmAuditResult;

    // Handle npm audit v2+ format
    if (audit.vulnerabilities) {
      for (const [packageName, vuln] of Object.entries(audit.vulnerabilities)) {
        const parsed = this.parseNpmAuditVulnerability(packageName, vuln);
        if (parsed) {
          vulnerabilities.push(parsed);
        }
      }
    }

    // Sort by severity (critical first)
    return vulnerabilities.sort((a, b) => {
      const order: Record<VulnerabilitySeverity, number> = {
        critical: 0,
        high: 1,
        medium: 2,
        low: 3,
      };
      return order[a.severity] - order[b.severity];
    });
  }

  /**
   * Parse a single npm audit vulnerability entry.
   */
  private static parseNpmAuditVulnerability(
    packageName: string,
    vuln: NpmAuditVulnerability
  ): SecurityVulnerability | null {
    // Find the most relevant "via" entry with CVE/CVSS info
    let cveId = '';
    let cvssScore: number | null = null;
    let description = '';

    for (const via of vuln.via) {
      // Skip if via is just a dependency reference
      if (typeof via === 'string') continue;

      // Extract CVE from URL if present
      if (via.url) {
        const cves = this.extractCVEs(via.url);
        if (cves.length > 0) {
          cveId = cves[0];
        }
      }

      // Extract CVSS score
      if (via.cvss) {
        const score = this.parseCVSSScore(via.cvss);
        if (score !== null && (cvssScore === null || score > cvssScore)) {
          cvssScore = score;
        }
      }

      // Use title as description
      if (via.title && !description) {
        description = via.title;
      }
    }

    // Determine severity: prefer CVSS score, fall back to label
    const severity = cvssScore !== null
      ? this.severityFromCVSS(cvssScore)
      : this.parseSeverityLabel(vuln.severity);

    // Generate description if none found
    if (!description) {
      description = `Security vulnerability in ${packageName}`;
      if (cvssScore !== null) {
        description += ` (CVSS ${cvssScore.toFixed(1)})`;
      }
    }

    return {
      name: packageName,
      cveId,
      severity,
      affectedVersions: vuln.range,
      description,
    };
  }

  /**
   * Create a SecurityVulnerability with sensible defaults.
   *
   * @param data - Partial vulnerability data (name required)
   * @returns Complete SecurityVulnerability object
   */
  static createVulnerability(
    data: Partial<SecurityVulnerability> & { name: string }
  ): SecurityVulnerability {
    return {
      name: data.name,
      cveId: data.cveId ?? '',
      severity: data.severity ?? 'medium',
      affectedVersions: data.affectedVersions ?? '*',
      description: data.description ?? `Vulnerability in ${data.name}`,
    };
  }
}

export type { ParsedCVE, CVSSScore, NpmAuditResult, NpmAuditVulnerability };
```

### Enhanced MaintenanceAnalyzer

Update `packages/orchestrator/src/analyzers/maintenance-analyzer.ts`:

```typescript
import { SecurityVulnerabilityParser } from '../utils/security-vulnerability-parser';
import type { SecurityVulnerability, VulnerabilitySeverity } from '../idle-processor';

export class MaintenanceAnalyzer extends BaseAnalyzer {
  readonly type = 'maintenance' as const;

  analyze(analysis: ProjectAnalysis): TaskCandidate[] {
    const candidates: TaskCandidate[] = [];

    // Use rich securityIssues if available, otherwise fall back to legacy
    const vulnerabilities = analysis.dependencies.securityIssues ?? [];

    if (vulnerabilities.length > 0) {
      this.analyzeSecurityVulnerabilities(vulnerabilities, candidates);
    } else if (analysis.dependencies.security.length > 0) {
      // Fallback to legacy format
      this.analyzeLegacySecurityIssues(analysis.dependencies.security, candidates);
    }

    // Existing outdated dependencies logic...
    // ...

    return candidates;
  }

  /**
   * Analyze rich security vulnerability data
   */
  private analyzeSecurityVulnerabilities(
    vulnerabilities: SecurityVulnerability[],
    candidates: TaskCandidate[]
  ): void {
    // Group by severity
    const bySeverity = this.groupBySeverity(vulnerabilities);

    // Critical vulnerabilities: individual urgent tasks
    for (const vuln of bySeverity.critical) {
      const id = vuln.cveId || `${vuln.name}-critical`;
      candidates.push(
        this.createCandidate(
          `security-critical-${id}`,
          `Fix Critical Vulnerability: ${vuln.cveId || vuln.name}`,
          this.formatVulnerabilityDescription(vuln),
          {
            priority: 'urgent',
            effort: 'high',
            workflow: 'maintenance',
            rationale: this.formatVulnerabilityRationale(vuln),
            score: 1.0,
          }
        )
      );
    }

    // High vulnerabilities: individual high-priority tasks
    for (const vuln of bySeverity.high) {
      const id = vuln.cveId || `${vuln.name}-high`;
      candidates.push(
        this.createCandidate(
          `security-high-${id}`,
          `Fix High-Severity Vulnerability: ${vuln.cveId || vuln.name}`,
          this.formatVulnerabilityDescription(vuln),
          {
            priority: 'high',
            effort: 'medium',
            workflow: 'maintenance',
            rationale: this.formatVulnerabilityRationale(vuln),
            score: 0.9,
          }
        )
      );
    }

    // Medium vulnerabilities: group task
    if (bySeverity.medium.length > 0) {
      candidates.push(
        this.createCandidate(
          'security-medium-group',
          `Fix ${bySeverity.medium.length} Medium-Severity Vulnerabilities`,
          this.formatGroupDescription(bySeverity.medium),
          {
            priority: 'normal',
            effort: bySeverity.medium.length > 5 ? 'high' : 'medium',
            workflow: 'maintenance',
            rationale: 'Medium severity vulnerabilities should be addressed in regular maintenance',
            score: 0.6,
          }
        )
      );
    }

    // Low vulnerabilities: aggregate task
    if (bySeverity.low.length > 0) {
      candidates.push(
        this.createCandidate(
          'security-low-group',
          `Address ${bySeverity.low.length} Low-Severity Vulnerabilities`,
          this.formatGroupDescription(bySeverity.low),
          {
            priority: 'low',
            effort: 'low',
            workflow: 'maintenance',
            rationale: 'Low severity vulnerabilities can be addressed during routine updates',
            score: 0.3,
          }
        )
      );
    }
  }

  /**
   * Group vulnerabilities by severity level
   */
  private groupBySeverity(vulnerabilities: SecurityVulnerability[]): Record<VulnerabilitySeverity, SecurityVulnerability[]> {
    return {
      critical: vulnerabilities.filter(v => v.severity === 'critical'),
      high: vulnerabilities.filter(v => v.severity === 'high'),
      medium: vulnerabilities.filter(v => v.severity === 'medium'),
      low: vulnerabilities.filter(v => v.severity === 'low'),
    };
  }

  /**
   * Format individual vulnerability description
   */
  private formatVulnerabilityDescription(vuln: SecurityVulnerability): string {
    const parts = [
      `Package: ${vuln.name}`,
      `Affected: ${vuln.affectedVersions}`,
    ];

    if (vuln.cveId) {
      parts.push(`CVE: ${vuln.cveId}`);
    }

    parts.push(`Severity: ${vuln.severity.toUpperCase()}`);
    parts.push('');
    parts.push(vuln.description);

    return parts.join('\n');
  }

  /**
   * Format vulnerability rationale
   */
  private formatVulnerabilityRationale(vuln: SecurityVulnerability): string {
    const prefix = vuln.severity === 'critical'
      ? 'CRITICAL: '
      : vuln.severity === 'high'
        ? 'HIGH: '
        : '';

    return `${prefix}${vuln.description}. Update ${vuln.name} to a patched version.`;
  }

  /**
   * Format grouped vulnerabilities description
   */
  private formatGroupDescription(vulnerabilities: SecurityVulnerability[]): string {
    const packages = vulnerabilities.map(v => {
      const cve = v.cveId ? ` (${v.cveId})` : '';
      return `- ${v.name}@${v.affectedVersions}${cve}`;
    });

    return `Address the following vulnerabilities:\n${packages.slice(0, 10).join('\n')}${vulnerabilities.length > 10 ? `\n... and ${vulnerabilities.length - 10} more` : ''}`;
  }

  /**
   * Fallback handler for legacy security format
   */
  private analyzeLegacySecurityIssues(
    securityIssues: string[],
    candidates: TaskCandidate[]
  ): void {
    // Attempt to parse CVEs from legacy strings
    const parsedVulnerabilities: SecurityVulnerability[] = [];

    for (const issue of securityIssues) {
      const cves = SecurityVulnerabilityParser.extractCVEs(issue);
      const severity = this.inferSeverityFromString(issue);

      parsedVulnerabilities.push(
        SecurityVulnerabilityParser.createVulnerability({
          name: this.extractPackageName(issue),
          cveId: cves[0] ?? '',
          severity,
          affectedVersions: this.extractVersion(issue),
          description: issue,
        })
      );
    }

    if (parsedVulnerabilities.length > 0) {
      this.analyzeSecurityVulnerabilities(parsedVulnerabilities, candidates);
    }
  }

  /**
   * Infer severity from legacy string format
   */
  private inferSeverityFromString(issue: string): VulnerabilitySeverity {
    const lower = issue.toLowerCase();
    if (lower.includes('critical')) return 'critical';
    if (lower.includes('high')) return 'high';
    if (lower.includes('moderate') || lower.includes('medium')) return 'medium';
    return 'low';
  }

  /**
   * Extract package name from legacy format "package@version (info)"
   */
  private extractPackageName(issue: string): string {
    const match = /^([^@\s]+)/.exec(issue);
    return match ? match[1] : 'unknown';
  }

  /**
   * Extract version from legacy format
   */
  private extractVersion(issue: string): string {
    const match = /@([^\s(]+)/.exec(issue);
    return match ? match[1] : '*';
  }
}
```

## Test Specifications

### Unit Test File: `packages/orchestrator/src/utils/security-vulnerability-parser.test.ts`

```typescript
import { describe, it, expect } from 'vitest';
import { SecurityVulnerabilityParser } from './security-vulnerability-parser';

describe('SecurityVulnerabilityParser', () => {
  // ============================================================================
  // CVE Extraction Tests
  // ============================================================================
  describe('extractCVEs', () => {
    it('should extract single CVE from text', () => {
      const result = SecurityVulnerabilityParser.extractCVEs(
        'Found CVE-2021-44228 in log4j'
      );
      expect(result).toEqual(['CVE-2021-44228']);
    });

    it('should extract multiple CVEs from text', () => {
      const result = SecurityVulnerabilityParser.extractCVEs(
        'Vulnerabilities: CVE-2021-44228, CVE-2023-12345'
      );
      expect(result).toEqual(['CVE-2021-44228', 'CVE-2023-12345']);
    });

    it('should handle extended CVE format with 5+ digit sequence', () => {
      const result = SecurityVulnerabilityParser.extractCVEs('CVE-2024-000001');
      expect(result).toEqual(['CVE-2024-000001']);
    });

    it('should deduplicate repeated CVEs', () => {
      const result = SecurityVulnerabilityParser.extractCVEs(
        'CVE-2021-44228 mentioned twice: CVE-2021-44228'
      );
      expect(result).toEqual(['CVE-2021-44228']);
    });

    it('should be case insensitive and normalize to uppercase', () => {
      const result = SecurityVulnerabilityParser.extractCVEs('cve-2021-44228');
      expect(result).toEqual(['CVE-2021-44228']);
    });

    it('should return empty array for no CVEs', () => {
      const result = SecurityVulnerabilityParser.extractCVEs(
        'No vulnerabilities found'
      );
      expect(result).toEqual([]);
    });

    it('should not match invalid CVE formats', () => {
      const result = SecurityVulnerabilityParser.extractCVEs(
        'CVE-21-123 CVE-2021-12 not-CVE-2021-1234'
      );
      expect(result).toEqual([]);
    });
  });

  // ============================================================================
  // CVE Validation Tests
  // ============================================================================
  describe('isValidCVE', () => {
    it('should validate standard CVE format', () => {
      expect(SecurityVulnerabilityParser.isValidCVE('CVE-2021-44228')).toBe(true);
    });

    it('should validate extended CVE format', () => {
      expect(SecurityVulnerabilityParser.isValidCVE('CVE-2024-000001')).toBe(true);
    });

    it('should reject short year', () => {
      expect(SecurityVulnerabilityParser.isValidCVE('CVE-21-44228')).toBe(false);
    });

    it('should reject short sequence', () => {
      expect(SecurityVulnerabilityParser.isValidCVE('CVE-2021-123')).toBe(false);
    });

    it('should be case insensitive', () => {
      expect(SecurityVulnerabilityParser.isValidCVE('cve-2021-44228')).toBe(true);
    });
  });

  // ============================================================================
  // CVSS Parsing Tests
  // ============================================================================
  describe('parseCVSSScore', () => {
    it('should parse numeric score directly', () => {
      expect(SecurityVulnerabilityParser.parseCVSSScore(9.8)).toBe(9.8);
    });

    it('should parse string score', () => {
      expect(SecurityVulnerabilityParser.parseCVSSScore('9.8')).toBe(9.8);
    });

    it('should parse object with score property', () => {
      expect(
        SecurityVulnerabilityParser.parseCVSSScore({ score: 9.8 })
      ).toBe(9.8);
    });

    it('should extract score from "CVSS: X.X" format', () => {
      expect(SecurityVulnerabilityParser.parseCVSSScore('CVSS: 9.8')).toBe(9.8);
    });

    it('should clamp score to valid range', () => {
      expect(SecurityVulnerabilityParser.parseCVSSScore(15)).toBe(10);
      expect(SecurityVulnerabilityParser.parseCVSSScore(-5)).toBe(0);
    });

    it('should return null for invalid input', () => {
      expect(SecurityVulnerabilityParser.parseCVSSScore('invalid')).toBeNull();
      expect(SecurityVulnerabilityParser.parseCVSSScore(null)).toBeNull();
      expect(SecurityVulnerabilityParser.parseCVSSScore(undefined)).toBeNull();
    });
  });

  // ============================================================================
  // Severity From CVSS Tests
  // ============================================================================
  describe('severityFromCVSS', () => {
    it('should return critical for 9.0-10.0', () => {
      expect(SecurityVulnerabilityParser.severityFromCVSS(9.0)).toBe('critical');
      expect(SecurityVulnerabilityParser.severityFromCVSS(10.0)).toBe('critical');
      expect(SecurityVulnerabilityParser.severityFromCVSS(9.5)).toBe('critical');
    });

    it('should return high for 7.0-8.9', () => {
      expect(SecurityVulnerabilityParser.severityFromCVSS(7.0)).toBe('high');
      expect(SecurityVulnerabilityParser.severityFromCVSS(8.9)).toBe('high');
      expect(SecurityVulnerabilityParser.severityFromCVSS(8.0)).toBe('high');
    });

    it('should return medium for 4.0-6.9', () => {
      expect(SecurityVulnerabilityParser.severityFromCVSS(4.0)).toBe('medium');
      expect(SecurityVulnerabilityParser.severityFromCVSS(6.9)).toBe('medium');
      expect(SecurityVulnerabilityParser.severityFromCVSS(5.5)).toBe('medium');
    });

    it('should return low for 0.1-3.9', () => {
      expect(SecurityVulnerabilityParser.severityFromCVSS(0.1)).toBe('low');
      expect(SecurityVulnerabilityParser.severityFromCVSS(3.9)).toBe('low');
      expect(SecurityVulnerabilityParser.severityFromCVSS(2.0)).toBe('low');
    });

    it('should handle edge cases', () => {
      expect(SecurityVulnerabilityParser.severityFromCVSS(0)).toBe('low');
      expect(SecurityVulnerabilityParser.severityFromCVSS(-1)).toBe('low');
      expect(SecurityVulnerabilityParser.severityFromCVSS(11)).toBe('critical');
    });
  });

  // ============================================================================
  // Severity Label Parsing Tests
  // ============================================================================
  describe('parseSeverityLabel', () => {
    it('should parse standard severity labels', () => {
      expect(SecurityVulnerabilityParser.parseSeverityLabel('critical')).toBe('critical');
      expect(SecurityVulnerabilityParser.parseSeverityLabel('high')).toBe('high');
      expect(SecurityVulnerabilityParser.parseSeverityLabel('medium')).toBe('medium');
      expect(SecurityVulnerabilityParser.parseSeverityLabel('low')).toBe('low');
    });

    it('should handle npm "moderate" label', () => {
      expect(SecurityVulnerabilityParser.parseSeverityLabel('moderate')).toBe('medium');
    });

    it('should handle "info" label', () => {
      expect(SecurityVulnerabilityParser.parseSeverityLabel('info')).toBe('low');
      expect(SecurityVulnerabilityParser.parseSeverityLabel('informational')).toBe('low');
    });

    it('should be case insensitive', () => {
      expect(SecurityVulnerabilityParser.parseSeverityLabel('CRITICAL')).toBe('critical');
      expect(SecurityVulnerabilityParser.parseSeverityLabel('High')).toBe('high');
    });

    it('should default to low for unknown labels', () => {
      expect(SecurityVulnerabilityParser.parseSeverityLabel('unknown')).toBe('low');
      expect(SecurityVulnerabilityParser.parseSeverityLabel('')).toBe('low');
    });
  });

  // ============================================================================
  // npm Audit Parsing Tests
  // ============================================================================
  describe('parseNpmAuditOutput', () => {
    it('should parse npm audit v2 format', () => {
      const auditOutput = {
        vulnerabilities: {
          'lodash': {
            name: 'lodash',
            severity: 'high',
            isDirect: true,
            via: [
              {
                source: 1234,
                title: 'Prototype Pollution',
                url: 'https://github.com/advisories/GHSA-xxxx',
                severity: 'high',
                cvss: { score: 7.4 },
                range: '<4.17.21',
              },
            ],
            effects: [],
            range: '<4.17.21',
            nodes: ['node_modules/lodash'],
            fixAvailable: true,
          },
        },
      };

      const result = SecurityVulnerabilityParser.parseNpmAuditOutput(auditOutput);

      expect(result).toHaveLength(1);
      expect(result[0].name).toBe('lodash');
      expect(result[0].severity).toBe('high');
      expect(result[0].affectedVersions).toBe('<4.17.21');
      expect(result[0].description).toBe('Prototype Pollution');
    });

    it('should extract CVE from URL', () => {
      const auditOutput = {
        vulnerabilities: {
          'log4j': {
            name: 'log4j',
            severity: 'critical',
            via: [
              {
                url: 'https://nvd.nist.gov/vuln/detail/CVE-2021-44228',
                severity: 'critical',
                cvss: { score: 10.0 },
              },
            ],
            effects: [],
            range: '<2.15.0',
            nodes: [],
            fixAvailable: true,
          },
        },
      };

      const result = SecurityVulnerabilityParser.parseNpmAuditOutput(auditOutput);

      expect(result[0].cveId).toBe('CVE-2021-44228');
    });

    it('should sort results by severity (critical first)', () => {
      const auditOutput = {
        vulnerabilities: {
          'low-pkg': {
            name: 'low-pkg',
            severity: 'low',
            via: [],
            effects: [],
            range: '*',
            nodes: [],
            fixAvailable: true,
          },
          'critical-pkg': {
            name: 'critical-pkg',
            severity: 'critical',
            via: [],
            effects: [],
            range: '*',
            nodes: [],
            fixAvailable: true,
          },
        },
      };

      const result = SecurityVulnerabilityParser.parseNpmAuditOutput(auditOutput);

      expect(result[0].severity).toBe('critical');
      expect(result[1].severity).toBe('low');
    });

    it('should handle empty audit output', () => {
      expect(SecurityVulnerabilityParser.parseNpmAuditOutput({})).toEqual([]);
      expect(SecurityVulnerabilityParser.parseNpmAuditOutput(null)).toEqual([]);
    });
  });

  // ============================================================================
  // Vulnerability Creation Tests
  // ============================================================================
  describe('createVulnerability', () => {
    it('should create vulnerability with defaults', () => {
      const result = SecurityVulnerabilityParser.createVulnerability({
        name: 'test-package',
      });

      expect(result).toEqual({
        name: 'test-package',
        cveId: '',
        severity: 'medium',
        affectedVersions: '*',
        description: 'Vulnerability in test-package',
      });
    });

    it('should preserve provided values', () => {
      const result = SecurityVulnerabilityParser.createVulnerability({
        name: 'log4j',
        cveId: 'CVE-2021-44228',
        severity: 'critical',
        affectedVersions: '<2.15.0',
        description: 'Remote code execution',
      });

      expect(result).toEqual({
        name: 'log4j',
        cveId: 'CVE-2021-44228',
        severity: 'critical',
        affectedVersions: '<2.15.0',
        description: 'Remote code execution',
      });
    });
  });
});
```

## Integration Test Specifications

See `packages/orchestrator/src/analyzers/maintenance-analyzer-security.test.ts` for comprehensive integration tests covering:

1. Critical vulnerability task generation
2. Severity grouping
3. Legacy format fallback
4. Task prioritization
5. Edge cases

## Performance Considerations

1. **Lazy Evaluation**: npm audit is only run when needed, not on every analysis
2. **Caching**: Results are cached for the duration of an analysis cycle
3. **Timeout Handling**: npm audit has a configurable timeout to prevent hangs
4. **Result Limiting**: Large vulnerability lists are truncated in task descriptions

## Migration Notes

1. The legacy `security: string[]` field remains for backward compatibility
2. New code should prefer `securityIssues: SecurityVulnerability[]`
3. The parser gracefully handles both formats
